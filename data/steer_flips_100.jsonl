{"state": "case a\nM : Type u_1\nN : Type u_2\nA : Type u_3\ninst\u271d\u00b9 : MulOneClass M\ns\u271d : Set M\ninst\u271d : AddZeroClass A\nt : Set A\nS : Submonoid M\ns : Set M\n\u22a2 \u2191(closure s) \u2264 {1} \u222a \u2191(Subsemigroup.closure s)", "label": "intro", "pred_base": "apply", "pred_alpha": "intro", "score_base": -0.5023683309555054, "score_alpha": 18.24885368347168, "alpha": 2.0}
{"state": "case intro.intro\nG : Type u_1\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : TopologicalSpace G\ninst\u271d : TopologicalGroup G\nK\u2080 : PositiveCompacts G\neval : (Compacts G \u2192 \u211d) \u2192 \u211d := fun f => f \u22a5\nthis : Continuous eval\nU : Set G\nleft\u271d : U \u2208 {U | U \u2286 \u2191\u22a4.toOpens \u2227 IsOpen U \u2227 1 \u2208 U}\n\u22a2 prehaar (\u2191K\u2080) U \u2208 eval \u207b\u00b9' {0}", "label": "apply", "pred_base": "apply", "pred_alpha": "intro", "score_base": -5.524157524108887, "score_alpha": 16.942842483520508, "alpha": 2.0}
{"state": "case refine_1\n\u03b9 : Type u_1\nl : Filter \u03b9\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\n\ud835\udd5c : Type u_3\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup G\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G\nf : \u03b9 \u2192 E \u2192 G\ng : E \u2192 G\nf' : \u03b9 \u2192 E \u2192 E \u2192L[\ud835\udd5c] G\ng' : E \u2192 E \u2192L[\ud835\udd5c] G\nx : E\ninst\u271d : l.NeBot\nhf' : TendstoUniformlyOnFilter f' g' l (\ud835\udcdd x)\nhf : \u2200\u1da0 (n : \u03b9 \u00d7 E) in l \u00d7\u02e2 \ud835\udcdd x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2\nhfg : \u2200\u1da0 (y : E) in \ud835\udcdd x, Tendsto (fun n => f n y) l (\ud835\udcdd (g y))\nthis\u271d\u00b9 :\n  (fun a => (\u2191\u2016a.2 - x\u2016)\u207b\u00b9 \u2022 (g a.2 - g x - (g' x) (a.2 - x))) =\n    ((fun a => (\u2191\u2016a.2 - x\u2016)\u207b\u00b9 \u2022 (g a.2 - g x - (f a.1 a.2 - f a.1 x))) + fun a =>\n        (\u2191\u2016a.2 - x\u2016)\u207b\u00b9 \u2022 (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +\n      fun a => (\u2191\u2016a.2 - x\u2016)\u207b\u00b9 \u2022 (f' a.1 x - g' x) (a.2 - x)\nthis\u271d : \ud835\udcdd 0 = \ud835\udcdd (0 + 0 + 0)\nthis :\n  \u2200 \u03b5 > 0,\n    \u2200\u1da0 (n : \u03b9 \u00d7 E) in l \u00d7\u02e2 \ud835\udcdd x, dist ((\u2191\u2016n.2 - x\u2016)\u207b\u00b9 \u2022 (g n.2 - g x)) ((\u2191\u2016n.2 - x\u2016)\u207b\u00b9 \u2022 (f n.1 n.2 - f n.1 x)) < \u03b5\n\u22a2 \u2200 \u03b5 > 0,\n    \u2200\u1da0 (x_1 : \u03b9 \u00d7 E) in l.curry (\ud835\udcdd x), dist ((\u2191\u2016x_1.2 - x\u2016)\u207b\u00b9 \u2022 (g x_1.2 - g x - (f x_1.1 x_1.2 - f x_1.1 x))) 0 < \u03b5", "label": "intro", "pred_base": "apply", "pred_alpha": "intro", "score_base": -2.065178155899048, "score_alpha": 22.944091796875, "alpha": 2.0}
{"state": "case intro\nC : Type u\u2081\ninst\u271d\u2074 : Category.{u\u2082, u\u2081} C\ninst\u271d\u00b3 : GaloisCategory C\nF\u271d : C \u2964 FintypeCat\ninst\u271d\u00b2 : FiberFunctor F\u271d\nA B : C\ninst\u271d\u00b9 : IsConnected A\ninst\u271d : IsGalois B\nf : A \u27f6 B\n\u03c3 \u03c4 : Aut A\nF : C \u2964 FintypeCat := GaloisCategory.getFiberFunctor C\na : \u2191(F.obj A)\n\u22a2 autMap f (\u03c3 * \u03c4) = autMap f \u03c3 * autMap f \u03c4", "label": "apply", "pred_base": "apply", "pred_alpha": "intro", "score_base": -7.152618885040283, "score_alpha": 17.184206008911133, "alpha": 2.0}
{"state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf\u271d f : \u03b1 \u2192 \u211d\nA : \u211d\nx : \u03b1\nh : |f x| < A\nH : f x \u2209 Set.Ioc (-A) A\n\u22a2 0 = f x", "label": "apply", "pred_base": "apply", "pred_alpha": "intro", "score_base": -4.226545810699463, "score_alpha": 15.903966903686523, "alpha": 2.0}
{"state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nc c' : Chain \u03b1\nf : \u03b1 \u2192o \u03b2\ng\u271d : \u03b2 \u2192o \u03b3\ng : \u03b1 \u2192o \u03b2\nh : f \u2264 g\ni : \u2115\n\u22a2 f (c i) \u2264 g (c i)", "label": "apply", "pred_base": "apply", "pred_alpha": "intro", "score_base": -3.559941053390503, "score_alpha": 13.235380172729492, "alpha": 2.0}
{"state": "n : \u2115\nP : MvPFunctor.{u} (n + 1)\n\u03b1 : TypeVec.{u} n\nR : P.M \u03b1 \u2192 P.M \u03b1 \u2192 Prop\nh\u2080 : Equivalence R\nh : \u2200 (x y : P.M \u03b1), R x y \u2192 (TypeVec.id ::: Quot.mk R) <$$> dest P x = (TypeVec.id ::: Quot.mk R) <$$> dest P y\nx y : P.M \u03b1\nr : R x y\n\u22a2 x = y", "label": "apply", "pred_base": "apply", "pred_alpha": "intro", "score_base": -8.584429740905762, "score_alpha": 16.202783584594727, "alpha": 2.0}
{"state": "C : Type u\ninst\u271d\u2074 : Category.{v, u} C\ninst\u271d\u00b3 : ConcreteCategory C\ninst\u271d\u00b2 : HasLimits C\ninst\u271d\u00b9 : ConcreteCategory.forget.ReflectsIsomorphisms\ninst\u271d : PreservesLimits ConcreteCategory.forget\nX : TopCat\nF : Sheaf C X\n\u03b9 : Type v\nU : \u03b9 \u2192 Opens \u2191X\ns t : (CategoryTheory.forget C).obj (F.val.obj { unop := iSup U })\nh : \u2200 (i : \u03b9), (F.val.map (leSupr U i).op) s = (F.val.map (leSupr U i).op) t\nsf : (i : \u03b9) \u2192 (CategoryTheory.forget C).obj (F.val.obj { unop := U i }) := fun i => (F.val.map (leSupr U i).op) s\n\u22a2 IsCompatible F.val U sf", "label": "intro", "pred_base": "apply", "pred_alpha": "intro", "score_base": -1.4205107688903809, "score_alpha": 27.52458953857422, "alpha": 2.0}
{"state": "a b c : Cardinal.{u_1}\nh : a + b = c\nha : a < c\nhc : \u2135\u2080 \u2264 c\n\u22a2 b = c", "label": "apply", "pred_base": "apply", "pred_alpha": "intro", "score_base": -7.168356418609619, "score_alpha": 12.164142608642578, "alpha": 2.0}
{"state": "case isOpen_range.hs.self\nJ : Type v\ninst\u271d : SmallCategory J\nX\u271d Y\u271d Z\u271d W X Y Z S T : TopCat\nf\u2081 : W \u27f6 S\nf\u2082 : X \u27f6 S\ng\u2081 : Y \u27f6 T\ng\u2082 : Z \u27f6 T\ni\u2081 : W \u27f6 Y\ni\u2082 : X \u27f6 Z\nH\u2081 : OpenEmbedding \u21d1i\u2081\nH\u2082 : OpenEmbedding \u21d1i\u2082\ni\u2083 : S \u27f6 T\nH\u2083 : Mono i\u2083\neq\u2081 : f\u2081 \u226b i\u2083 = i\u2081 \u226b g\u2081\neq\u2082 : f\u2082 \u226b i\u2083 = i\u2082 \u226b g\u2082\n\u22a2 Continuous \u21d1pullback.fst", "label": "apply", "pred_base": "apply", "pred_alpha": "intro", "score_base": -2.295513153076172, "score_alpha": 21.522249221801758, "alpha": 2.0}
